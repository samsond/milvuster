// This file is @generated by prost-build.
/// *
/// @brief Field schema
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldSchema {
    #[prost(int64, tag = "1")]
    pub field_id: i64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_primary_key: bool,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "DataType", tag = "5")]
    pub data_type: i32,
    #[prost(message, repeated, tag = "6")]
    pub type_params: ::prost::alloc::vec::Vec<super::common::KeyValuePair>,
    #[prost(message, repeated, tag = "7")]
    pub index_params: ::prost::alloc::vec::Vec<super::common::KeyValuePair>,
    #[prost(bool, tag = "8")]
    pub auto_id: bool,
    /// To keep compatible with older version, the default
    #[prost(enumeration = "FieldState", tag = "9")]
    pub state: i32,
    /// state is `Created`.
    ///
    /// For array type, the element type is stored here
    #[prost(enumeration = "DataType", tag = "10")]
    pub element_type: i32,
    /// default_value only support scalars except array and json for now
    #[prost(message, optional, tag = "11")]
    pub default_value: ::core::option::Option<ValueField>,
    /// mark whether this field is the dynamic field
    #[prost(bool, tag = "12")]
    pub is_dynamic: bool,
    /// enable logic partitions
    #[prost(bool, tag = "13")]
    pub is_partition_key: bool,
    #[prost(bool, tag = "14")]
    pub is_clustering_key: bool,
    /// enable set null as field value
    #[prost(bool, tag = "15")]
    pub nullable: bool,
    #[prost(bool, tag = "16")]
    pub is_function_output: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub id: i64,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "FunctionType", tag = "4")]
    pub r#type: i32,
    #[prost(string, repeated, tag = "5")]
    pub input_field_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, repeated, tag = "6")]
    pub input_field_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "7")]
    pub output_field_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, repeated, tag = "8")]
    pub output_field_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "9")]
    pub params: ::prost::alloc::vec::Vec<super::common::KeyValuePair>,
}
/// *
/// @brief Collection schema
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// deprecated later, keep compatible with c++ part now
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub auto_id: bool,
    #[prost(message, repeated, tag = "4")]
    pub fields: ::prost::alloc::vec::Vec<FieldSchema>,
    /// mark whether this table has the dynamic field function enabled.
    #[prost(bool, tag = "5")]
    pub enable_dynamic_field: bool,
    #[prost(message, repeated, tag = "6")]
    pub properties: ::prost::alloc::vec::Vec<super::common::KeyValuePair>,
    #[prost(message, repeated, tag = "7")]
    pub functions: ::prost::alloc::vec::Vec<FunctionSchema>,
    #[prost(string, tag = "8")]
    pub db_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolArray {
    #[prost(bool, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntArray {
    #[prost(int32, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LongArray {
    #[prost(int64, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatArray {
    #[prost(float, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleArray {
    #[prost(double, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<f64>,
}
/// For special fields such as bigdecimal, array...
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BytesArray {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArray {
    #[prost(string, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayArray {
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<ScalarField>,
    #[prost(enumeration = "DataType", tag = "2")]
    pub element_type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonArray {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeometryArray {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueField {
    #[prost(oneof = "value_field::Data", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub data: ::core::option::Option<value_field::Data>,
}
/// Nested message and enum types in `ValueField`.
pub mod value_field {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(bool, tag = "1")]
        BoolData(bool),
        #[prost(int32, tag = "2")]
        IntData(i32),
        #[prost(int64, tag = "3")]
        LongData(i64),
        #[prost(float, tag = "4")]
        FloatData(f32),
        #[prost(double, tag = "5")]
        DoubleData(f64),
        #[prost(string, tag = "6")]
        StringData(::prost::alloc::string::String),
        #[prost(bytes, tag = "7")]
        BytesData(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarField {
    #[prost(oneof = "scalar_field::Data", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub data: ::core::option::Option<scalar_field::Data>,
}
/// Nested message and enum types in `ScalarField`.
pub mod scalar_field {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        BoolData(super::BoolArray),
        #[prost(message, tag = "2")]
        IntData(super::IntArray),
        #[prost(message, tag = "3")]
        LongData(super::LongArray),
        #[prost(message, tag = "4")]
        FloatData(super::FloatArray),
        #[prost(message, tag = "5")]
        DoubleData(super::DoubleArray),
        #[prost(message, tag = "6")]
        StringData(super::StringArray),
        #[prost(message, tag = "7")]
        BytesData(super::BytesArray),
        #[prost(message, tag = "8")]
        ArrayData(super::ArrayArray),
        #[prost(message, tag = "9")]
        JsonData(super::JsonArray),
        #[prost(message, tag = "10")]
        GeometryData(super::GeometryArray),
    }
}
/// beta, api may change
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseFloatArray {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// dim is the max dimension of the current batch of vectors
    #[prost(int64, tag = "2")]
    pub dim: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorField {
    /// For sparse vector, dim is the max dimension of the current batch of vectors
    #[prost(int64, tag = "1")]
    pub dim: i64,
    #[prost(oneof = "vector_field::Data", tags = "2, 3, 4, 5, 6, 7")]
    pub data: ::core::option::Option<vector_field::Data>,
}
/// Nested message and enum types in `VectorField`.
pub mod vector_field {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "2")]
        FloatVector(super::FloatArray),
        #[prost(bytes, tag = "3")]
        BinaryVector(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "4")]
        Float16Vector(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "5")]
        Bfloat16Vector(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "6")]
        SparseFloatVector(super::SparseFloatArray),
        #[prost(bytes, tag = "7")]
        Int8Vector(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldData {
    #[prost(enumeration = "DataType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub field_id: i64,
    #[prost(bool, tag = "6")]
    pub is_dynamic: bool,
    #[prost(bool, repeated, tag = "7")]
    pub valid_data: ::prost::alloc::vec::Vec<bool>,
    #[prost(oneof = "field_data::Field", tags = "3, 4")]
    pub field: ::core::option::Option<field_data::Field>,
}
/// Nested message and enum types in `FieldData`.
pub mod field_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Field {
        #[prost(message, tag = "3")]
        Scalars(super::ScalarField),
        #[prost(message, tag = "4")]
        Vectors(super::VectorField),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IDs {
    #[prost(oneof = "i_ds::IdField", tags = "1, 2")]
    pub id_field: ::core::option::Option<i_ds::IdField>,
}
/// Nested message and enum types in `IDs`.
pub mod i_ds {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IdField {
        #[prost(message, tag = "1")]
        IntId(super::LongArray),
        #[prost(message, tag = "2")]
        StrId(super::StringArray),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchIteratorV2Results {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub last_bound: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResultData {
    #[prost(int64, tag = "1")]
    pub num_queries: i64,
    #[prost(int64, tag = "2")]
    pub top_k: i64,
    #[prost(message, repeated, tag = "3")]
    pub fields_data: ::prost::alloc::vec::Vec<FieldData>,
    #[prost(float, repeated, tag = "4")]
    pub scores: ::prost::alloc::vec::Vec<f32>,
    #[prost(message, optional, tag = "5")]
    pub ids: ::core::option::Option<IDs>,
    #[prost(int64, repeated, tag = "6")]
    pub topks: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "7")]
    pub output_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub group_by_field_value: ::core::option::Option<FieldData>,
    #[prost(int64, tag = "9")]
    pub all_search_count: i64,
    #[prost(float, repeated, tag = "10")]
    pub distances: ::prost::alloc::vec::Vec<f32>,
    #[prost(message, optional, tag = "11")]
    pub search_iterator_v2_results: ::core::option::Option<SearchIteratorV2Results>,
    #[prost(float, repeated, tag = "12")]
    pub recalls: ::prost::alloc::vec::Vec<f32>,
    #[prost(string, tag = "13")]
    pub primary_field_name: ::prost::alloc::string::String,
}
/// vector field clustering info
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorClusteringInfo {
    /// for multi vectors
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub centroid: ::core::option::Option<VectorField>,
}
/// Scalar field clustering info
/// todo more definitions: min/max, etc
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalarClusteringInfo {
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
}
/// clustering distribution info of a certain data unit, it can be segment, partition, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusteringInfo {
    #[prost(message, repeated, tag = "1")]
    pub vector_clustering_infos: ::prost::alloc::vec::Vec<VectorClusteringInfo>,
    #[prost(message, repeated, tag = "2")]
    pub scalar_clustering_infos: ::prost::alloc::vec::Vec<ScalarClusteringInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateValue {
    #[prost(oneof = "template_value::Val", tags = "1, 2, 3, 4, 5")]
    pub val: ::core::option::Option<template_value::Val>,
}
/// Nested message and enum types in `TemplateValue`.
pub mod template_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Val {
        #[prost(bool, tag = "1")]
        BoolVal(bool),
        #[prost(int64, tag = "2")]
        Int64Val(i64),
        #[prost(double, tag = "3")]
        FloatVal(f64),
        #[prost(string, tag = "4")]
        StringVal(::prost::alloc::string::String),
        #[prost(message, tag = "5")]
        ArrayVal(super::TemplateArrayValue),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateArrayValue {
    #[prost(oneof = "template_array_value::Data", tags = "1, 2, 3, 4, 5, 6")]
    pub data: ::core::option::Option<template_array_value::Data>,
}
/// Nested message and enum types in `TemplateArrayValue`.
pub mod template_array_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        BoolData(super::BoolArray),
        #[prost(message, tag = "2")]
        LongData(super::LongArray),
        #[prost(message, tag = "3")]
        DoubleData(super::DoubleArray),
        #[prost(message, tag = "4")]
        StringData(super::StringArray),
        #[prost(message, tag = "5")]
        ArrayData(super::TemplateArrayValueArray),
        #[prost(message, tag = "6")]
        JsonData(super::JsonArray),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateArrayValueArray {
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<TemplateArrayValue>,
}
/// *
/// @brief Field data type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
    None = 0,
    Bool = 1,
    Int8 = 2,
    Int16 = 3,
    Int32 = 4,
    Int64 = 5,
    Float = 10,
    Double = 11,
    String = 20,
    /// variable-length strings with a specified maximum length
    VarChar = 21,
    Array = 22,
    Json = 23,
    Geometry = 24,
    BinaryVector = 100,
    FloatVector = 101,
    Float16Vector = 102,
    BFloat16Vector = 103,
    SparseFloatVector = 104,
    Int8Vector = 105,
}
impl DataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Bool => "Bool",
            Self::Int8 => "Int8",
            Self::Int16 => "Int16",
            Self::Int32 => "Int32",
            Self::Int64 => "Int64",
            Self::Float => "Float",
            Self::Double => "Double",
            Self::String => "String",
            Self::VarChar => "VarChar",
            Self::Array => "Array",
            Self::Json => "JSON",
            Self::Geometry => "Geometry",
            Self::BinaryVector => "BinaryVector",
            Self::FloatVector => "FloatVector",
            Self::Float16Vector => "Float16Vector",
            Self::BFloat16Vector => "BFloat16Vector",
            Self::SparseFloatVector => "SparseFloatVector",
            Self::Int8Vector => "Int8Vector",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "None" => Some(Self::None),
            "Bool" => Some(Self::Bool),
            "Int8" => Some(Self::Int8),
            "Int16" => Some(Self::Int16),
            "Int32" => Some(Self::Int32),
            "Int64" => Some(Self::Int64),
            "Float" => Some(Self::Float),
            "Double" => Some(Self::Double),
            "String" => Some(Self::String),
            "VarChar" => Some(Self::VarChar),
            "Array" => Some(Self::Array),
            "JSON" => Some(Self::Json),
            "Geometry" => Some(Self::Geometry),
            "BinaryVector" => Some(Self::BinaryVector),
            "FloatVector" => Some(Self::FloatVector),
            "Float16Vector" => Some(Self::Float16Vector),
            "BFloat16Vector" => Some(Self::BFloat16Vector),
            "SparseFloatVector" => Some(Self::SparseFloatVector),
            "Int8Vector" => Some(Self::Int8Vector),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionType {
    Unknown = 0,
    Bm25 = 1,
    TextEmbedding = 2,
}
impl FunctionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Bm25 => "BM25",
            Self::TextEmbedding => "TextEmbedding",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "BM25" => Some(Self::Bm25),
            "TextEmbedding" => Some(Self::TextEmbedding),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldState {
    FieldCreated = 0,
    FieldCreating = 1,
    FieldDropping = 2,
    FieldDropped = 3,
}
impl FieldState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FieldCreated => "FieldCreated",
            Self::FieldCreating => "FieldCreating",
            Self::FieldDropping => "FieldDropping",
            Self::FieldDropped => "FieldDropped",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FieldCreated" => Some(Self::FieldCreated),
            "FieldCreating" => Some(Self::FieldCreating),
            "FieldDropping" => Some(Self::FieldDropping),
            "FieldDropped" => Some(Self::FieldDropped),
            _ => None,
        }
    }
}
